#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned int uint;

void read_map(char* inp, int* N, int* M, unsigned char** map)
{
    int i, j;
    int d;
    sscanf(inp, "%d", N);
    if (*N < 10)
        inp += 2;
    else
        inp += 3;
    sscanf(inp, "%d", M);
    if (*M < 10)
        inp += 2;
    else
        inp += 3;
    printf("%d %d\n", *N, *M);
    *map = (unsigned char*) malloc((*N)*(*M));
    for (i=0; i<*N; i++)
    {
        for (j=0; j<*M; j++)
        {
            inp += 2*sscanf(inp, "%d", &d);
            (*map)[i*(*M)+j] = (unsigned char) d;
            printf("%d ", d);
        }
        printf("\n");
    }
}


int eq(unsigned char* map, int i1, int j1, int i2, int j2, int M)
{
    return map[i1*M+j1] == map[i2*M+j2];
}


void evaluate_map(int N, int M, unsigned char* map, uint* c, uint* r)
{
    int i, j, p;
    uint A, B, C, D;
    for (i=0; i<N*M; i++)
    {
        r[i] = i;
    }
    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (i>0)
                A = c[(i-1)*M + j];
            else
                A = -1;
            if (j>0)
                B = c[i*M + j-1];
            else
                B = -1;
            if (i == 0 && j == 0)
            {
                p = 0;
            }
            else if (i == 0)
            {
                if (eq(map, i, j, i, j-1, M))
                    p = 1;
                else
                    p = 0;
            }
            else if (j == 0)
            {
                if (eq(map, i, j, i-1, j, M))
                    p = 2;
                else
                    p = 0;
            }
            else if (eq(map, i, j, i, j-1, M))
            {
                if (eq(map, i, j, i-1, j, M))
                    p = 3;
                else
                    p = 1;
            }
            else if (eq(map, i, j, i-1, j, M))
                p = 2;
            else
                p = 0;
            
            if (p==0)
            {
                c[i*M + j] = i*M + j;
            }
            else if (p==1)
            {
                c[i*M + j] = B;
            }
            else if (p==2)
            {
                c[i*M + j] = A;
            }
            else
            {
                C = A;
                while (r[C] != C)
                    C = r[C];
                D = B;
                while (r[D] != D)
                    D = r[D];
                if (C > D)
                    C = D;
                while (r[A] != A)
                {
                    D = r[A];
                    r[A] = C;
                    A = D;
                }
                while (r[B] != B)
                {
                    D = r[B];
                    r[B] = C;
                    B = D;
                }
                if (r[A] > C)
                    r[A] = C;
                else
                    r[B] = C;
                c[i*M + j-1] = C;
                c[(i-1)*M + j] = C;
                c[i*M + j] = C;
            }
        }
    }

    for (i=0; i<N*M; i++)
    {
        C = i;
        while (r[C] != C)
            C = r[C];
        r[i] = C;
    }

    for (i=0; i<N; i++)
        for (j=0; j<M; j++)
            c[i*M + j] = r[c[i*M + j]];

    for (i=0; i<N-1; i++)
        for (j=0; j<M; j++)
            if (!eq(map, i, j, i+1, j, M))
            {
                if (map[i*M + j] < map[(i+1)*M + j])
                    r[c[(i+1)*M + j]] = N*M;
                else
                    r[c[i*M + j]] = N*M;
            }

    for (i=0; i<N; i++)
        for (j=0; j<M-1; j++)
            if (!eq(map, i, j, i, j+1, M))
            {
                if (map[i*M + j] < map[i*M + j+1])
                    r[c[i*M + j+1]] = N*M;
                else
                    r[c[i*M + j]] = N*M;
            }

}


void print_map(int N, int M, unsigned char* map, uint* c, uint* r)
{
    int i, j;
    printf("\n");
    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            //printf("%d ", c[i*M + j]);
            if (c[i*M + j] != N*M && r[c[i*M + j]] == i*M + j)
                printf(". ");
            else
                printf("%d ", map[i*M + j]);
        }
        printf("\n");
    }
}


void distribute(int N, int M, unsigned char* map, uint* c, uint* r)
{
    int i, j;
    uint C = 0;
    uint D;
    // Compress color indices
    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (r[c[i*M + j]] == i*M + j)
                r[c[i*M + j]] = C++;
        }
    }

    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (r[c[i*M + j]] != N*M)
                c[i*M + j] = r[c[i*M + j]];
            else
                c[i*M + j] = N*M;
        }
    }

    if (3*C > M*N)
        exit(1);

    for (i=0; i<3*C; i++)
        r[i] = 0;

    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (c[i*M + j] != N*M)
            {
                D = 3*c[i*M + j];
                r[D] += i;
                r[D+1] += j;
                r[D+2]++;
            }
        }
    }

    for (i=0; i<C; i++)
    {
        D = 3*i;
        r[D] = (int) (((float) r[D]) / r[D+2] + 0.5);
        r[D+1]  = (int) (((float) r[D+1]) / r[D+2] + 0.5);

        r[D+2] = r[D]*M + r[D+1];
        r[D] = N*N + M*M;
        r[D+1] = N*M;
    }

    // Find the closest point to the mass center
    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (c[i*M + j] != N*M)
            {
                D = 3*c[i*M + j];
                C = (r[D+2]%M - j)*(r[D+2]%M - j) + (r[D+2]/M - i)*(r[D+2]/M - i);
                if (C < r[D])
                {
                   r[D+1] = i*M + j;
                   r[D] = C;
                }
            }
        }
    } 

    // Compute number of colors
    C = 0;
    for (i=0; i<N; i++)
    {
        for (j=0; j<M; j++)
        {
            if (c[i*M + j] != N*M && c[i*M + j] >= C)
                C++;
        }
    }
    
    // Keep only final coordinates
    for (i=0; i<C; i++)
    {
        r[i] = r[3*i + 1];
    }

}

int main()
{
    int N, M, i;
    unsigned char* map;
    uint* c;
    uint* r;

    char* inp[8]; 
    inp[0] = "7 7\n"
        "3 3 1 3 3 3 3\n"
        "3 2 1 3 5 5 3\n"
        "4 3 3 4 1 4 3\n"
        "4 4 4 4 4 4 4\n"
        "5 4 5 5 3 5 5\n"
        "4 4 5 4 4 5 4\n"
        "1 4 4 4 4 3 4\n";
    inp[1] = "3 7\n"
        "3 2 2 5 3 5 5\n"
        "2 1 2 5 3 5 5\n"
        "3 2 4 1 1 5 5\n";
    inp[2] = "3 3\n"
        "4 4 4\n"
        "4 4 4\n"
        "4 4 4\n";
    inp[3] = "3 6\n"
        "4 4 4 9 8 7\n"
        "4 3 4 2 1 6\n"
        "5 4 5 3 4 5\n";
    inp[4] = "9 9\n"
        "1 2 3 4 5 6 7 8 9\n"
        "2 3 4 5 6 7 8 9 1\n"
        "3 4 5 6 7 8 9 1 2\n"
        "4 5 6 7 8 9 1 2 3\n"
        "5 6 7 8 9 1 2 3 4\n"
        "6 7 8 9 1 2 3 4 5\n"
        "7 8 9 1 2 3 4 5 6\n"
        "8 9 1 2 3 4 5 6 7\n"
        "9 1 2 3 4 5 6 7 8\n";
    inp[5] = "20 20\n"
        "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2\n"
        "2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3\n"
        "3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4\n"
        "4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5\n"
        "5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6\n"
        "6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7\n"
        "7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8\n"
        "8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n"
        "9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1\n"
        "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2\n"
        "2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3\n"
        "3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4\n"
        "4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5\n"
        "5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6\n"
        "6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7\n"
        "7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8\n"
        "8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9\n"
        "9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1\n"
        "1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2\n"
        "2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3\n";
    inp[6] = "4 4\n"
       "1 1 1 2\n"
       "1 1 2 1\n"
       "1 2 1 1\n"
       "2 1 1 1\n"; 
    inp[7] = "21 95\n"
       "6 4 8 0 7 6 8 0 7 2 8 3 2 1 3 4 4 8 6 3 2 1 1 6 2 3 4 3 7 7 7 2 8 1 2 0 1 6 1 6 2 3 4 3 4 1 9 5 3 0 5 3 1 5 3 3 5 3 4 5 3 5 2 0 1 6 0 1 6 0 2 3 4 3 3 1 7 8 6 7 3 3 4 6 2 0 1 1 1 1 6 3 1 7 1\n"
       "7 3 1 7 0 4 5 3 3 2 7 3 1 8 0 1 5 1 2 3 4 3 7 5 6 8 1 6 2 2 0 1 0 6 3 0 7 0 3 2 3 3 6 2 3 2 3 3 3 7 0 1 0 9 3 3 3 1 1 0 0 3 3 3 1 9 3 3 6 1 6 1 0 6 3 3 3 0 1 0 4 3 6 3 7 3 7 2 3 6 9 2 5 3 1\n"
       "4 2 0 1 0 0 6 2 3 3 3 3 1 0 0 1 0 0 4 3 6 3 8 3 7 2 3 6 9 2 5 3 1 9 5 3 0 2 0 1 0 0 0 7 4 3 8 3 8 3 4 3 6 2 0 1 0 0 0 0 0 6 3 9 9 1 0 0 6 3 3 3 8 6 1 1 0 0 9 3 3 3 1 8 6 1 2 3 1 0 1 0 0 0 3\n"
       "3 3 8 3 1 0 3 4 3 1 1 0 6 3 8 0 6 2 3 6 3 8 3 1 0 0 0 0 7 0 1 1 4 6 7 2 8 1 7 5 6 8 1 1 7 6 2 2 1 4 6 7 2 8 1 7 5 6 8 1 1 7 7 2 2 1 4 6 7 2 8 1 7 5 6 8 1 1 7 8 2 2 1 4 6 7 2 8 1 7 5 6 8 1 1\n"
       "7 9 2 2 1 4 6 7 2 8 1 7 5 6 8 1 1 7 9 6 2 2 1 4 6 7 2 8 1 7 5 6 8 1 3 2 2 1 4 3 0 2 2 3 3 3 2 9 0 7 3 1 1 6 3 1 7 3 1 7 0 3 0 3 2 3 7 7 8 7 3 2 3 2 0 3 4 3 7 2 8 3 3 2 3 6 9 0 8 3 1 2 3 3 3\n"
       "0 7 0 0 4 3 1 4 3 6 3 7 3 3 7 2 3 6 9 2 5 3 1 6 0 2 0 1 0 4 6 7 2 8 1 7 3 2 1 0 4 3 6 3 7 4 3 7 2 3 6 9 2 5 3 1 6 0 2 0 1 0 0 3 3 3 3 2 3 7 3 1 0 0 4 3 3 3 2 3 7 4 1 0 0 5 3 3 3 7 5 6 8 1 3\n"
       "7 0 2 3 8 3 2 1 0 0 6 3 3 3 7 5 6 8 1 3 3 3 3 4 3 4 3 4 3 4 3 0 7 7 5 2 1 1 6 3 3 7 3 1 8 0 5 5 1 1 0 0 3 3 3 3 3 3 8 3 6 1 0 0 4 3 3 3 4 3 8 3 6 1 0 0 5 3 3 3 5 3 8 3 6 1 1 6 3 4 7 3 2 0 0\n"
       "4 5 1 0 0 7 3 3 3 1 8 4 0 0 7 0 1 0 0 4 3 6 3 7 8 3 7 2 3 6 9 2 5 3 1 6 2 0 0 5 3 2 0 0 4 1 2 0 1 0 0 0 9 3 3 3 0 7 5 1 0 0 0 0 3 3 3 7 3 3 3 7 8 1 0 0 0 1 3 3 3 6 1 9 3 3 3 4 3 0 3 4 2 8 5\n"
       "1 0 0 0 6 3 3 3 7 5 6 8 1 0 7 7 5 3 4 3 0 3 0 3 4 3 1 3 1 2 1 0 0 0 9 3 3 3 9 3 8 3 6 1 0 0 0 0 3 3 3 0 3 8 3 6 1 0 0 0 1 3 3 3 1 3 8 3 6 1 0 0 0 7 3 3 3 4 3 1 3 6 3 5 3 0 1 0 0 0 8 3 3 3 6\n"
       "3 3 1 3 4 3 5 3 9 1 0 0 0 9 3 3 3 3 3 0 3 6 3 4 3 9 1 0 0 0 6 3 3 3 7 5 6 8 1 7 3 7 3 4 3 8 3 8 3 4 3 9 3 9 2 1 0 0 0 7 3 3 3 7 3 8 3 6 1 0 0 0 8 3 3 3 8 3 8 3 6 1 0 0 0 9 3 3 3 9 3 8 3 6 1\n"
       "1 1 0 0 0 6 3 4 7 1 3 2 1 0 0 5 1 0 0 0 6 3 9 0 0 8 7 4 0 7 3 6 3 4 9 6 3 7 5 6 8 1 3 8 2 2 3 4 3 0 6 3 5 0 3 3 0 9 3 2 3 6 1 3 3 1 5 5 6 2 3 3 3 1 7 0 1 0 0 0 5 3 3 3 0 7 5 3 3 6 3 1 7 0 3\n"
       "8 3 7 5 6 8 1 6 2 1 0 0 0 6 3 3 3 7 5 6 8 1 3 2 3 8 3 2 3 3 6 1 7 0 3 8 3 7 5 6 8 1 2 2 1 0 0 0 7 3 3 3 1 7 0 3 8 3 7 5 6 8 1 2 2 3 3 6 1 7 0 3 8 3 7 5 6 8 1 3 2 1 0 0 0 5 2 3 3 3 5 1 0 0 0\n"
       "6 2 3 3 3 6 1 0 0 0 7 2 3 3 3 7 1 0 0 0 0 2 3 3 3 5 2 3 9 3 4 3 6 2 3 0 3 4 3 7 2 3 1 1 0 0 0 1 2 3 3 3 5 2 3 7 3 4 3 6 2 3 8 3 4 3 7 2 3 9 1 0 0 0 4 3 6 3 8 3 7 2 3 6 9 2 5 3 1 6 2 0 1 0 0\n"
       "0 0 5 1 3 3 3 5 2 1 0 0 0 0 6 1 3 3 3 6 2 1 0 0 0 0 7 3 3 3 7 2 1 0 0 0 0 5 2 3 3 3 5 1 3 5 3 6 3 6 1 3 6 1 0 0 0 0 6 2 3 3 3 6 1 3 5 3 4 3 5 1 3 6 1 0 0 0 0 7 2 3 3 3 6 7 1 0 0 0 0 0 3 3 3\n"
       "0 2 1 0 0 0 0 1 3 3 3 1 2 1 0 0 0 0 0 2 3 3 3 5 2 3 9 3 4 3 6 2 3 0 3 4 3 7 2 3 1 1 0 0 0 0 1 2 3 3 3 5 2 3 7 3 4 3 6 2 3 8 3 4 3 7 2 3 9 1 0 0 0 3 3 3 1 0 0 0 0 6 4 6 7 2 8 1 0 2 5 3 1 2 5\n"
       "3 5 2 3 5 2 4 6 2 3 6 2 2 1 1 0 0 0 0 2 3 3 3 0 7 5 3 7 5 6 8 1 1 7 5 2 3 3 6 3 0 7 5 3 3 3 1 7 5 6 8 1 3 8 2 2 2 1 0 0 0 0 7 4 3 1 0 6 2 2 3 1 0 2 6 2 2 3 2 3 0 0 1 0 0 0 0 0 7 3 3 3 1 3 4\n"
       "3 1 1 2 6 1 2 3 1 2 6 0 2 8 1 0 2 6 0 2 1 0 0 0 0 0 7 4 3 6 2 3 2 3 7 3 2 3 2 0 1 0 0 0 0 0 0 0 6 3 9 9 1 0 0 0 0 7 4 3 1 0 4 2 2 3 1 0 2 4 2 2 3 2 3 0 0 1 0 0 0 0 0 7 3 3 3 1 3 4 3 1 1 2 6\n"
       "1 2 3 1 6 2 6 0 2 8 1 0 2 6 0 2 1 0 0 0 0 0 7 4 3 6 2 3 2 3 7 3 2 3 2 0 1 0 0 0 0 0 0 0 6 3 9 9 1 0 0 0 0 7 4 3 1 1 6 2 2 3 1 1 2 6 2 2 3 2 3 0 0 1 0 0 0 0 0 8 3 3 3 0 3 4 3 1 0 2 6 0 2 3 1\n"
       "2 6 1 2 8 1 1 2 6 1 2 1 0 0 0 0 0 7 4 3 6 2 3 2 3 8 3 2 3 2 0 1 0 0 0 0 0 0 0 6 3 9 9 1 0 0 0 0 7 4 3 1 1 4 2 2 3 1 1 2 4 2 2 3 2 3 0 0 1 0 0 0 0 0 8 3 3 3 0 3 4 3 1 0 2 6 0 2 3 1 6 2 6 1 2\n"
       "8 1 1 2 6 1 2 1 0 0 0 0 0 7 4 3 6 2 3 2 3 8 3 2 3 2 0 1 0 0 0 0 0 0 0 6 3 9 9 1 0 0 0 0 7 4 3 8 3 3 3 3 5 0 1 0 0 0 0 0 6 4 6 7 2 8 1 3 5 3 4 5 3 0 2 0 0 1 0 0 0 0 0 4 6 7 2 8 1 7 3 5 3 7 4\n"
       "5 3 7 8 5 3 3 5 3 4 5 3 0 2 1 0 0 0 0 0 4 3 0 2 2 3 3 3 6 6 0 3 1 0 0 0 7 4 3 4 3 0 2 2 0 1 0 0 0 0 0 6 3 9 9 1 0 0 7 4 3 4 3 0 2 2 0 1 0 0 0 0 6 3 9 9 1 0 7 4 3 4 3 0 2 2 0 1 0 0 0 6 3 9 9\n";

    for (i=0; i<8; i++)
    {
        read_map(inp[i], &N, &M, &map);

        c = (uint*) malloc(N*M*sizeof(uint));
        r = (uint*) malloc(N*M*sizeof(uint));

        evaluate_map(N, M, map, c, r);

        print_map(N, M, map, c, r);

        distribute(N, M, map, c, r);

        print_map(N, M, map, c, r);

        free(map);
        free(c);
        free(r);
    }

}
